package code.autoplay.replay.tracking;

import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.math.BigInteger;
import java.net.URL;
import java.util.ArrayList;
import java.util.Scanner;

import com.jme.math.FastMath;
import com.jme.math.Matrix3f;
import com.jme.math.Quaternion;
import com.jme.math.Vector3f;
import com.jme.util.Timer;

/**
 * Used to generate simulated data that mimics the data generated by Inertial Measurement Units (IMUs).
 * The data generated is hard-coded into the methods. 
 *  
 * @author Jordan Hinshaw
 *
 */
public class DataGenerator {
	//Constants
	private static final float STANDARD_G = 9.80665f;
	private static final long DEFUALT_FREQ = 100;
	private static final double DEFAULT_SIM_TIME = 10;
	private static final Vector3f UP = new Vector3f(0, 0, 1);
	private static final double SIN_LENG = 2 * Math.PI;
	private static final long UNSIGNED_INT_MAX = Long.valueOf("FFFFFFFF", 16);
	private static final long TICKS_PER_SEC = 19660800;
	
	public static final String TEST_FILE = "src/data/autoplay/test1.txt";
	
	private static final Matrix3f COORD_MULT =
		new Quaternion(0.7071067811865476f, 0f, 0f, -0.7071067811865476f).toRotationMatrix();
		//new Quaternion().fromAngleAxis(90*FastMath.DEG_TO_RAD, new Vector3f(1,0,0)).toRotationMatrix();
	
	//Variables
	private ArrayList<float[]> output;
	private long sampleTime;
	private long numSamples;
	private long count;
	private Quaternion rot;
	private Timer t;
	private long resolution;
	private double runtime;
	private boolean stop = false;
	
	public DataGenerator() {
		this(DEFAULT_SIM_TIME, DEFUALT_FREQ);
	}
	
	/**
	 * Constructor. 
	 */
	public DataGenerator(double time, long freq) {
		output = new  ArrayList<float[]>();
		runtime = time;
		count = 0;
		
		//set up timer
		t = Timer.getTimer();
		resolution = t.getResolution();
		
		//set up initial rotation
		rot = new Quaternion();
		
		//determine total number of samples and frequency
		if(freq <= resolution) {
			numSamples = freq;
			sampleTime = resolution / freq;
		}
		else {
			numSamples = resolution;
			sampleTime = 1;
		}
	}
	
	
	
	private float[] generateAccel() {
		
		float[] accelList = new float[3]; 
		
		//x-axis accel. based on sine curve
		if(t.getTimeInSeconds() <= 10 ||  (t.getTimeInSeconds() > 80 && t.getTimeInSeconds() < 90) ) {
			accelList[0] = 0.1f;
		}
		else if((t.getTimeInSeconds() > 30 && t.getTimeInSeconds() < 40) || 
				(t.getTimeInSeconds() > 50 && t.getTimeInSeconds() < 60) ) {
			accelList[0] = -0.1f;
		}
		else {// if(t.getTimeInSeconds() <= 30 && t.getTimeInSeconds() > 10) {
			accelList[0] = 0f;
		}
		
		
		//accelList[0] = 0f;//(float) Math.sin(SIN_LENG * count/numSamples); 
		
		//y-axis accel. should be 0, since pallet jack should not move sideways
		accelList[1] = 0f; 
		
		//z-axis accel. should always reflect gravity.
		accelList[2] = -1f; 
		
		return accelList;
	}
	
	
	private float[] generateRotation() {
		//Pallet jack should only be rotated significantly around the z-axis.
		//A small amount of rotation may occur around the x-axis if pallet
		//jack moves up a hill.
		
		/*double zRot = Math.asin(-1 + ((double) count)/numSamples);
		rot.fromAngleNormalAxis((float) zRot, UP);*/
		Matrix3f rotMat;
		
		if(t.getTimeInSeconds() > 40 && t.getTimeInSeconds() < 50) {
			Quaternion temp = new Quaternion(0f, 0f, 0.008726535498373935f, 0.9999619230641713f);
			//Quaternion temp = new Quaternion(new float[]{0, 0, 1 * FastMath.DEG_TO_RAD});
				//System.out.println(new Quaternion(new float[]{0, 0, 1 * FastMath.DEG_TO_RAD})); 
			rotMat = temp.toRotationMatrix();
			//System.out.println(rotMat);
		}
		else {
			rotMat = new Quaternion().toRotationMatrix();
		}
		
		
		//simulate z and y -axis switching
		/*if( rotMat.isIdentity() ) {
			rotMat.multLocal(COORD_MULT);
		}*/
		
		
		//System.out.println(new Quaternion().fromRotationMatrix(rotMat));
		
		float[] data = new float[9];
		rotMat.get(data, true);
		
		return data;
	}
	
	private int generateTime(long jmeTime) {
		
		//convert from Timer ticks to IMU timer ticks
		double sec = ((double) jmeTime) / resolution;
		long ticks = (long) (sec * TICKS_PER_SEC) % UNSIGNED_INT_MAX;
		
		//timer resets when it reaches the max value of an unsigned int
		/*if(ticks > UNSIGNED_INT_MAX) {
			ticks %= UNSIGNED_INT_MAX;
		}*/
		
		//if the simulation has run for at least the desired runtime generate
		//a stop signal.
		if(sec >= runtime) {
			stop = true;
		}
		
		//for testing purposes
		//System.out.println(ticks);
		
		/* Converts long value to hexadecimal string and then to an
		 * integer. This is dones to simulate an *unsigned* integer
		 * value that would be returned by the MicroStrain IMU device.
		 * The Xsens device would return a 16-bit unsigned counter 
		 * that would function similarly.*/
		String hx = Long.toHexString(ticks);
		
		String ch;
		int result = 0;
		int len = hx.length();
		
		for(int i=0; i < len; i++) {
			result <<= 4;
			ch = Character.toString(hx.charAt(i));
			result ^= Byte.parseByte(ch, 16);
		}
		
		return result;
	}
	
	
	private void increaseCount() {
		//prevents counter from exceeding twice the total totalSamples,
		//which would cause a NaN result for the asin() function used
		//in the generateRotation() function.
		count = (count < 2 * sampleTime) ? count + 1 : 0;
	}
	
	public boolean generate(PrintStream out) {
		long time = t.getTime();
		long prevTime = -1;
		float[] accel;
		float[] rotMat;
		
		//Stops when the simulation has run for the desired time. 
		//See generateTime() 
		while(!stop) {
			
			//used to simulate frequency. Only outputs every sampleTime ticks.  
			if(time % sampleTime == 0 && time != prevTime) {
				accel = generateAccel();
				rotMat = generateRotation();
				
				//print acceleration output to file
				for(float f : accel) {
					out.print(f + " ");
				}
				
				//print rotation output to file
				for(float f : rotMat) {
					out.print(f + " ");
				}
				
				//print timer to file
				out.println( generateTime(time) );
				out.flush();
				
				//increases the counter
				increaseCount();
				
				//update prevTime to prevent multiple entries per time
				prevTime = time;
			}
			
			time = t.getTime();
		}
		
		//Flushes output stream and checks for errors.
		//checkError() returns true if an error has occurred. 
		return !out.checkError();
	}
	
	public static void main(String[] args) {
		DataGenerator d = new DataGenerator(90, 100);
		
		try {
			Timer t = Timer.getTimer();
			System.out.println(t.getTime() + "   " + t.getResolution());
			PrintStream out = new PrintStream(TEST_FILE);
			d.generate(out);
			//d.generate(System.out);
			out.close();
			System.out.println(t.getTime() + "   " + t.getResolution());
		} 
		catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}
}
